use std::error::Error;
use std::ffi::OsString;
use std::fs::File;
use std::io::{prelude::*, Cursor};
use std::io;
use std::time::Duration;
use tokio::net::TcpStream;

use futures::{stream, StreamExt};

use byteorder::{ReadBytesExt, WriteBytesExt, BigEndian};

use tokio;
use clap::Parser;
use tokio::io::AsyncReadExt;

use serde::{Serialize, Deserialize};
use tokio::time::timeout;

const TCP_TIMEOUT: Duration = Duration::from_secs(15);
const BUFFER_AMOUNT: usize = 1000;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// input XML file generated by masscan
    #[arg(short, long)]
    file: OsString
}

#[derive(Serialize, Deserialize, Debug)]
struct Version {
    name: String,
    protocol: i32,
}

#[derive(Serialize, Deserialize, Debug)]
struct PlayerSample {
    name: String,
    id: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Players {
    max: i32,
    online: i32,
    sample: Option<Vec<PlayerSample>>,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(untagged)]
enum DescriptionType {
    String(String),
    Component(TextComponent)
}

#[derive(Serialize, Deserialize, Debug)]
struct TextComponent {
    extra: Option<Vec<DescriptionType>>,
    text: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Status {
    version: Version,
    players: Option<Players>,
    description: DescriptionType,
    favicon: Option<String>,
    #[serde(rename = "enforcesSecureChat")]
    enforces_secure_chat: Option<bool>,
    #[serde(rename = "previewsChat")]
    previews_chat: Option<bool>,
}

#[tokio::main]
async fn main() {
    let args = Args::parse();

    let file_name = args.file;
    let mut file = File::open(file_name).unwrap();
    let raw_xml = {
        let mut raw = String::new();
        file.read_to_string(&mut raw).unwrap();
        raw
    };

    let doc = roxmltree::Document::parse(&raw_xml).unwrap();

    let mut addrs = vec![];
    for node in doc.descendants() {
        if node.is_element() && node.tag_name() == "address".into() {
            let addr = node.attribute("addr").unwrap();
            addrs.push(addr);
        }
    }

    println!("Checking {} ip addresses", addrs.len());

    let bodies = stream::iter(addrs)
        .map(|ip| async move {
            // Attempt a connection to the ip at 25565
            // TODO: other ports idk but also idc
            let mut stream = TcpStream::connect(format!("{ip}:25565")).await?;
           
            // Prepare and send handshake
            let mut buffer = Vec::new();
            buffer.write_varint(0x00)?;
            buffer.write_varint(765)?;
            buffer.write_string(ip)?;
            buffer.write_u16::<BigEndian>(25565)?;
            buffer.write_varint(1)?;

            let mut tmp = Vec::new();
            tmp.write_varint(buffer.len() as i32)?;

            // stream.write_varint(buffer.len() as i32)?;
            // stream.write(&[0x14])?;
            stream.try_write(&[tmp, buffer].concat())?;
            
            let mut tmp = Vec::new();
            tmp.write_varint(0x01)?;
            tmp.write_varint(0x00)?;

            stream.try_write(&tmp)?;

            let len = stream.read_varint_async().await?;
            let mut buf = vec![0; len as usize];
            stream.read_exact(&mut buf).await?;
            let mut c = Cursor::new(buf);

            Ok::<(&str, String), Box<dyn Error>>(match c.read_varint()? {
                0x00 => (ip, c.read_string()?),
                _ => panic!("erm")
            })
        })
        .map(|f| timeout(TCP_TIMEOUT, f))
        .buffer_unordered(BUFFER_AMOUNT);

    bodies
        .for_each(|body| async {
            if let Ok(body) = body {
                match body {
                    Ok((ip, body)) => {
                        // println!("{body}");
                        let status: Status = serde_json::from_str(&body).unwrap();
                        // println!("{}: {:?}", ip, status);

                        println!("Server found at {ip}:25565!");
                        println!("⤷ Version: {}", status.version.name);
                        println!("⤷ Players: {}", match status.players {
                            Some(players) => format!("{}/{}", players.online, players.max),
                            None => "???/??? (server has disabled player listings)".into()
                        });
                        println!("⤷ Description: {}", text_component_to_raw(&status.description));
                    },
                    Err(_) => (),
                }
            }
        }).await;
}

fn text_component_to_raw(component: &DescriptionType) -> String {
    match component {
        DescriptionType::String(s) => s.into(),
        DescriptionType::Component(component) => {
            let mut string = component.text.clone();
            
            if let Some(extras) = &component.extra {
                for component in extras {
                    string.push_str(&text_component_to_raw(&component))
                }
            }

            string
        },
    }
}

// idk I kinda just copied this lool
trait ReadJavaExt: Read + ReadBytesExt {
    fn read_varint(&mut self) -> io::Result<i32> {
        let mut res = 0i32;
        for i in 0..5 {
            let part = self.read_u8()?;
            res |= (part as i32 & 0x7F) << (7 * i);
            if part & 0x80 == 0 {
                return Ok(res);
            }
        }
        Err(io::Error::new(io::ErrorKind::Other, "VarInt too big!"))
    }

    fn read_string(&mut self) -> io::Result<String> {
        let len = self.read_varint()? as usize;
        let mut buf = vec![0; len as usize];
        self.read_exact(&mut buf)?;
        Ok(String::from_utf8(buf).expect("Invalid UTF-8 String"))
    }
}

impl<T> ReadJavaExt for T where T: Read + ReadBytesExt {}


trait AsyncReadJavaExt: Unpin + AsyncReadExt {
    async fn read_varint_async(&mut self) -> io::Result<i32> {
        let mut res = 0i32;
        for i in 0..5 {
            let part: u8 = self.read_u8().await?;
            res |= (part as i32 & 0x7F) << (7 * i);
            if part & 0x80 == 0 {
                return Ok(res);
            }
        }
        Err(io::Error::new(io::ErrorKind::Other, "VarInt too big!"))
    }

    async fn read_string_async(&mut self) -> io::Result<String> {
        let len = self.read_varint_async().await? as usize;
        let mut buf = vec![0; len as usize];
        self.read_exact(&mut buf).await?;
        Ok(String::from_utf8(buf).expect("Invalid UTF-8 String"))
    }
}

impl<T> AsyncReadJavaExt for T where T: Unpin + AsyncReadExt {}

trait WriteJavaExt: Write + WriteBytesExt {
    fn write_varint(&mut self, mut val: i32) -> io::Result<()> {
        for _ in 0..5 {
            if val & !0x7F == 0 {
                self.write_u8(val as u8)?;
                return Ok(());
            }
            self.write_u8((val & 0x7F | 0x80) as u8)?;
            val >>= 7;
        }
        Err(io::Error::new(io::ErrorKind::Other, "VarInt too big!"))
    }

    fn write_string(&mut self, s: &str) -> io::Result<()> {
        self.write_varint(s.len() as i32)?;
        self.write_all(s.as_bytes())?;
        Ok(())
    }
}

impl<T> WriteJavaExt for T where T: Write + WriteBytesExt {}
